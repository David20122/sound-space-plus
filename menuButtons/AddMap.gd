extends VBoxContainer

const valid_chars = "0123456789abcdefghijklmnopqrstuvwxyz_-"
var id_rex:RegEx = RegEx.new()

func check_requirements():
	var sname:String = $SongName/Value.text
	var mapper:String = $Mapper/Value.text
	
	if sname.length() != 0:
		var txt:String = ""
		if mapper.length() != 0:
			for i in range(mapper.length()):
				if mapper.to_lower()[i].is_subsequence_of(valid_chars):
					txt += mapper.to_lower()[i]
				elif mapper[i] == " " and txt[txt.length()-1] != "_":
					txt += "_"
			if txt[txt.length()-1] != "_": txt += "_"
		for i in range(sname.length()):
			if sname.to_lower()[i].is_subsequence_of(valid_chars):
				txt += sname.to_lower()[i]
			elif sname[i] == " " and txt[txt.length()-1] != "_": txt += "_"
		$ID/Value.placeholder_text = txt.trim_prefix("_").trim_suffix("_")
	else: $ID/Value.placeholder_text = "(will autogenerate)"
	
	
	if ($Import.path or $Import.data) and $Song.path and sname.length() != 0:
		var id = $ID/Value.text
		if id == "" or !id: id = $ID/Value.placeholder_text
		var pack_name = $Pack/Pack.text
		if !pack_name: pack_name = "user"
		
		if $Pack.pressed:
			if pack_name.length() == 0 or pack_name.begins_with("_") or !("n" + pack_name).replace("-","").is_valid_identifier():
				$Add.disabled = true
				$Add.text = "invalid pack name"
				return false
		if id.length() == 0 or id.begins_with("_") or !("n" + id).replace("-","").is_valid_identifier():
			$Add.disabled = true
			$Add.text = "invalid ID"
			return false
		elif SSP.registry_song.get_item(id):
			$Add.disabled = true
			$Add.text = "ID already in use"
			return false
		else:
			$Add.disabled = false
			$Add.text = "add song"
			return true
	else:
		$Add.disabled = true
		var itms = []
		if !($Import.path or $Import.data): itms.append("data")
		if !$Song.path: itms.append("music")
		if sname.length() == 0: itms.append("song name")
		$Add.text = "missing: "
		for i in range(itms.size()):
			$Add.text += itms[i]
			if i != itms.size()-1: $Add.text += ", "
		return false

func add_map():
	if !check_requirements(): return false
	var id = $ID/Value.text
	if id == "" or !id: id = $ID/Value.placeholder_text
	var map:Song = Song.new(id, $SongName/Value.text, $Mapper/Value.text)
	map.difficulty = $Difficulty.difficulty
	var data_path = $Import.path
	var data = $Import.data
	var song_path = $Song.path
	
	if $Pack.pressed:
		var pack_name = $Pack/Pack.text
		if !pack_name: pack_name = "user"
		var dir:Directory = Directory.new()
		var file:File = File.new()
		dir.open(SSP.user_pack_dir)
		if !dir.dir_exists(pack_name): dir.make_dir(pack_name)
		dir.change_dir(pack_name)
		var store_type = Globals.MAPR_EMBEDDED
		var dataOrPath:String
		if $Import.use_file:
			store_type = Globals.MAPR_FILE
			dir.copy(data_path,SSP.user_pack_dir + "/" + pack_name + "/" + data_path.get_file())
			dataOrPath = data_path.get_file()
		else: dataOrPath = data
		dir.copy(song_path,SSP.user_pack_dir + "/" + pack_name + "/" + song_path.get_file())
		
		if file.file_exists(SSP.user_pack_dir + "/" + pack_name + "/pack.sspmr"):
			file.open(SSP.user_pack_dir + "/" + pack_name + "/pack.sspmr",File.READ_WRITE)
			file.seek_end()
		else:
			file.open(SSP.user_pack_dir + "/" + pack_name + "/pack.sspmr",File.WRITE)
#			file.store_line("#v1")
			file.store_line("# Generated by Sound Space+ v" + ProjectSettings.get_setting("application/config/version"))
			file.store_line("# type:~:id:~:name:~:creator:~:difficulty:~:rarity:~:musicPath:~:dataOrPath")
		file.store_line("%d:~:%s:~:%s:~:%s:~:%d:~:0:~:%s:~:%s" % [
			store_type,
			map.id,
			map.name,
			map.creator,
			map.difficulty,
			song_path.get_file(),
			dataOrPath
		])
		file.close()
	elif $Import.use_file: map.should_reload_on_play = true
	
	if $Import.use_file: map.setup_from_file(data_path,song_path)
	else: map.setup_from_data(data,song_path)
	SSP.registry_song.add_item(map)
	get_node("../../../ReloadMenu").modulate = Color("#55ff55")
	get_node("../../../ReloadMenu").grab_focus()
	
	check_requirements()
	

func on_songname_change(_txt):
	check_requirements()

func _ready():
	$SongName/Value.connect("text_changed",self,"on_songname_change")
	$Mapper/Value.connect("text_changed",self,"on_songname_change")
	$ID/Value.connect("text_changed",self,"on_songname_change")
	$Import.connect("data_changed",self,"check_requirements")
	$Song.connect("data_changed",self,"check_requirements")
	$Add.connect("pressed",self,"add_map")
	
